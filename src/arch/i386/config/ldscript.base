/*
 *	Memory map:
 *
 *	_RAMBASE		
 *				: data segment
 *				: bss segment
 *				: heap
 *				: stack
 *	_ROMBASE
 *				: linuxbios text 
 *				: readonly text
 *
 *      _ROMTOP                 : The top of the rom used where we
 *				  need to put the reset vector.
 */
/*
 * Bootstrap code for the STPC Consumer
 * Copyright (c) 1999 by Net Insight AB. All Rights Reserved.
 *
 * $Id$
 *
 */

_ROMTOP = (_ROMBASE >= 0xffff0000)? 0xfffffff0 : 0xffff0;
_start_offset = _start & 0xffff;
gdtptr_offset = gdtptr & 0xffff;
/*
 *	Written by Johan Rydberg, based on work by Daniel Kahlin.
 *      Rewritten by Eric Biederman
 */
/*
 *	We use ELF as output format. So that we can
 *	debug the code in some form. 
 */
OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)

/*
 *	Entry point is not really nececary, since the mkrom(8)
 *	tool creates a entry point that jumps to $0xc000:0x0000.
 */
/* baloney, but ... RGM*/
ENTRY(_start)

SECTIONS
{
	/*
	 * First we place the code and read only data (typically const declared).
	 * This get placed in rom.
	 */
	. = _ROMBASE;
	.text (.) : {
		_text = .;
		*(.text);
		*(.text.*)
		_etext = .;
	}
	.rodata (.) :  {
		_rodata = .;
		*(.rodata)
		_erodata = .;
	}

	. = _RAMBASE;

	/*
	 * After the code we place initialized data (typically initialized
	 * global variables). This gets copied into ram by startup code.
	 * __data_start and __data_end shows where in ram this should be placed,
	 * whereas __data_loadstart and __data_loadend shows where in rom to
	 * copy from.
	 */
	.data (.): AT(_erodata) {
		_data = .;
		*(.data)
		*(.sdata)
		*(.sdata2)
		_edata = .;
	}
	_ldata	= LOADADDR(.data);
	_eldata	= LOADADDR(.data) + SIZEOF(.data);
	/*
	 * bss does not contain data, it is just a space that should be zero
	 * initialized on startup. (typically uninitialized global variables)
	 * crt0.S fills between _bss and _ebss with zeroes.
	 */
	.bss (.): {
		_bss = .;
		*(.bss)
		*(.sbss)
		*(COMMON)
		_ebss = .;
	}
	_end = .;

	.heap (.): {
		_heap = .;
		/* Reserve 256K for the heap */
		. = . + ( HEAP_SIZE );
		_eheap = .;
	}
	.stack (.) : {
		_stack = .;
		/* Reserve 64k stack for each possible cpu */
		. = . + ((MAX_CPUS) * (STACK_SIZE));
		_estack = .;
	}
	_lreset = _eldata;
	. = _lreset;
	_deadspace = (_ROMTOP - _lreset);
	.reset (.) : AT (_lreset) {
		. = . + _deadspace;
		_reset_vector = .;
		*(.reset_vector)
		_ereset_vector = . ;
		. = .  + (16 - (1 + (_ereset_vector - _reset_vector)));
		BYTE(0x00);
	} 
	_elreset = _lreset + SIZEOF(.reset);
	/DISCARD/ : {
		*(*)
	}
}
