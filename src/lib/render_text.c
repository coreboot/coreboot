/* SPDX-License-Identifier: GPL-2.0-or-later */

#include <bootsplash.h>
#include <console/console.h>
#include <stdlib.h>
#include <string.h>

#include "fonts/fonts.h"
#include "render_bmp.h"

/* Major dimension for panel */
#define PANEL_4K 3840
#define PANEL_2K_QHD 2560

/* Determine scaling factor based on display resolution */
static uint32_t get_resolution_scale(struct logo_config *config)
{
	uint32_t width = config->horizontal_resolution;
	uint32_t height = config->vertical_resolution;
	uint32_t major_dim = (width > height) ? width : height;

	if (major_dim >= PANEL_4K)
		return 3;
	else if (major_dim >= PANEL_2K_QHD)
		return 2;
	else /* HD / FHD Panels */
		return 1;
}

/* Maps an unsigned character to the 8-bit alpha map (smoothing data) */
static const uint8_t *get_glyph_data(unsigned char c)
{
	/* Range check using macros generated by Python */
	if (c < FONT_START_CHAR || c > FONT_END_CHAR)
		return font_table[0]; /* Default to space character */

	return font_table[c - FONT_START_CHAR];
}

/* Retrieves the pre-calculated width for a character */
static uint8_t get_glyph_width(unsigned char c)
{
	if (c < FONT_START_CHAR || c > FONT_END_CHAR)
		return font_widths[0];

	return font_widths[c - FONT_START_CHAR];
}

/*
 * Maps local glyph coordinates to physical framebuffer coordinates
 * based on the panel's physical orientation.
 */
static inline void get_rotated_text_coords(struct logo_config *config,
		uint32_t x, uint32_t y, int row, int col, uint32_t *fb_x, uint32_t *fb_y)
{
	switch (config->panel_orientation) {
	case LB_FB_ORIENTATION_RIGHT_UP:
		*fb_x = x + (CONFIG_FONT_HEIGHT - 1 - row);
		*fb_y = y + col;
		break;
	case LB_FB_ORIENTATION_LEFT_UP:
		*fb_x = x + row;
		*fb_y = y + (CONFIG_FONT_WIDTH - 1 - col);
		break;
	case LB_FB_ORIENTATION_BOTTOM_UP:
		*fb_x = x + (CONFIG_FONT_WIDTH - 1 - col);
		*fb_y = y + (CONFIG_FONT_HEIGHT - 1 - row);
		break;
	default: /* LB_FB_ORIENTATION_NORMAL */
		*fb_x = x + col;
		*fb_y = y + row;
		break;
	}
}

/*
 * Renders a single character to the framebuffer.
 * @config: Framebuffer and orientation configuration.
 * @c:      Character to render.
 * @x, @y:  Starting coordinates in the virtual grid.
 * @color:  Primary text color.
 */
static void draw_char(struct logo_config *config, unsigned char c, uint32_t x, uint32_t y,
		struct blt_pixel color, uint32_t scale)
{
	size_t pixel_size = sizeof(struct blt_pixel);
	uint8_t *fb = (uint8_t *)config->framebuffer_base;

	const uint8_t *glyph = get_glyph_data(c);
	uint8_t actual_width = get_glyph_width(c);

	for (int row = 0; row < CONFIG_FONT_HEIGHT; row++) {
		for (int col = 0; col < actual_width; col++) {
			/* Get the 8-bit alpha value (0-255) for this pixel */
			uint8_t alpha = glyph[row * CONFIG_FONT_WIDTH + col];

			if (alpha == 0)
				continue;

			/* Fill a scale x scale block for each font pixel */
			for (uint32_t sy = 0; sy < scale; sy++) {
				for (uint32_t sx = 0; sx < scale; sx++) {
					uint32_t fb_x, fb_y;
					get_rotated_text_coords(config, x, y,
						(row * scale) + sy,
						(col * scale) + sx,
						&fb_x, &fb_y);

					if (fb_x < config->horizontal_resolution &&
					    fb_y < config->vertical_resolution) {
						struct blt_pixel *bg = (struct blt_pixel *)
							(fb + (fb_y * config->bytes_per_scanline) + (fb_x * pixel_size));

						if (alpha == 255) {
							*bg = color;
						} else {
							bg->Red = (uint8_t)((color.Red * alpha + bg->Red *
										 (255 - alpha)) / 255);
							bg->Green = (uint8_t)((color.Green * alpha + bg->Green *
										 (255 - alpha)) / 255);
							bg->Blue = (uint8_t)((color.Blue * alpha + bg->Blue *
										 (255 - alpha)) / 255);
						}
					}
				}
			}
		}
	}
}

static bool setup_text_alignment(struct logo_config *config,
	 enum bootsplash_text_type type, enum fw_splash_horizontal_alignment *halign,
	 enum fw_splash_vertical_alignment *valign, uint32_t *margin)
{
	/* Default to center/center */
	*halign = FW_SPLASH_HALIGNMENT_CENTER;
	*valign = FW_SPLASH_VALIGNMENT_CENTER;
	*margin = 0;

	if (type == BOOTSPLASH_TEXT_CENTER)
		return true;

	if (type != BOOTSPLASH_TEXT_FOOTER) {
		printk(BIOS_ERR, "%s: Invalid text type %d\n", __func__, type);
		return false;
	}

	*margin = config->logo_bottom_margin;

	switch (config->panel_orientation) {
	case LB_FB_ORIENTATION_RIGHT_UP:
		*halign = FW_SPLASH_HALIGNMENT_LEFT;
		*valign = FW_SPLASH_VALIGNMENT_CENTER;
		break;
	case LB_FB_ORIENTATION_LEFT_UP:
		*halign = FW_SPLASH_HALIGNMENT_RIGHT;
		*valign = FW_SPLASH_VALIGNMENT_CENTER;
		break;
	case LB_FB_ORIENTATION_BOTTOM_UP:
		*halign = FW_SPLASH_HALIGNMENT_CENTER;
		*valign = FW_SPLASH_VALIGNMENT_TOP;
		break;
	default: /* LB_FB_ORIENTATION_NORMAL */
		*halign = FW_SPLASH_HALIGNMENT_CENTER;
		*valign = FW_SPLASH_VALIGNMENT_BOTTOM;
		break;
	}

	return true;
}

/*
 * Renders a string centered on the screen.
 * @config: Framebuffer and logo configuration.
 * @str:    The null-terminated string to render.
 * @type:   Type of bootsplash text (i.e., enum bootsplash_text_type).
 */
void render_text_to_framebuffer(struct logo_config *config, const char *str,
	enum bootsplash_text_type type)
{
	if (!config || !str || config->framebuffer_base == 0)
		return;

	size_t len = strlen(str);
	if (len == 0)
		return;

	uint32_t scale = get_resolution_scale(config);
	const uint32_t kerning = 1 * scale;
	uint32_t total_width = 0;

	for (size_t i = 0; i < len; i++)
		total_width += (get_glyph_width((unsigned char)str[i]) * scale) + kerning;

	uint32_t text_w, text_h;
	enum fw_splash_horizontal_alignment halign;
	enum fw_splash_vertical_alignment valign;
	uint32_t margin;

	if (setup_text_alignment(config, type, &halign, &valign, &margin) == false)
		return;

	if (config->panel_orientation == LB_FB_ORIENTATION_LEFT_UP ||
			 config->panel_orientation == LB_FB_ORIENTATION_RIGHT_UP) {
		text_w = CONFIG_FONT_HEIGHT * scale;
		text_h = total_width;
	} else {
		text_w = total_width;
		text_h = CONFIG_FONT_HEIGHT * scale;
	}

	struct logo_coordinates coords = calculate_logo_coordinates(config->horizontal_resolution,
				 config->vertical_resolution, text_w, text_h, halign, valign);

	switch (config->panel_orientation) {
	case LB_FB_ORIENTATION_RIGHT_UP:
		coords.x += margin;
		break;
	case LB_FB_ORIENTATION_LEFT_UP:
		coords.x -= margin;
		coords.y += total_width;
		break;
	case LB_FB_ORIENTATION_BOTTOM_UP:
		coords.x += total_width;
		coords.y += margin;
		break;
	default: /* LB_FB_ORIENTATION_NORMAL (default) */
		coords.y -= margin;
	}

	/* Text Color: White (Default) */
	struct blt_pixel text_color = { .Red = 0xff, .Green = 0xff, .Blue = 0xff };
	uint32_t cur_x = coords.x;
	uint32_t cur_y = coords.y;

	/* Loop through characters and draw them */
	for (size_t i = 0; i < len; i++) {
		unsigned char c = (unsigned char)str[i];
		draw_char(config, c, cur_x, cur_y, text_color, scale);

		uint32_t advance = (get_glyph_width(c) * scale) + kerning;
		if (config->panel_orientation == LB_FB_ORIENTATION_RIGHT_UP)
			cur_y += advance;
		else if (config->panel_orientation == LB_FB_ORIENTATION_LEFT_UP)
			cur_y -= advance;
		else if (config->panel_orientation == LB_FB_ORIENTATION_BOTTOM_UP)
			cur_x -= advance;
		else
			cur_x += advance;
	}
}
