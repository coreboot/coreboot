uses HAVE_MP_TABLE
uses HAVE_PIRQ_TABLE
uses USE_FALLBACK_IMAGE
uses HAVE_FALLBACK_BOOT
uses HAVE_HARD_RESET
uses HARD_RESET_BUS
uses HARD_RESET_DEVICE
uses HARD_RESET_FUNCTION
uses IRQ_SLOT_COUNT
uses HAVE_OPTION_TABLE
uses CONFIG_MAX_CPUS
uses CONFIG_IOAPIC
uses CONFIG_SMP
uses FALLBACK_SIZE
uses ROM_SIZE
uses ROM_SECTION_SIZE
uses ROM_IMAGE_SIZE
uses ROM_SECTION_SIZE
uses ROM_SECTION_OFFSET
uses CONFIG_ROM_STREAM
uses CONFIG_ROM_STREAM_START
uses PAYLOAD_SIZE
uses _ROMBASE
uses XIP_ROM_SIZE
uses XIP_ROM_BASE
uses STACK_SIZE
uses HEAP_SIZE
uses USE_OPTION_TABLE
uses LB_CKS_RANGE_START
uses LB_CKS_RANGE_END
uses LB_CKS_LOC
uses MAINBOARD_PART_NUMBER
uses MAINBOARD_VENDOR


## ROM_SIZE is the size of boot ROM that this board will use.
default ROM_SIZE=524288

###
### Build options
###

##
## Build code for the fallback boot
##
default HAVE_FALLBACK_BOOT=1

##
## Build code to reset the motherboard from linuxBIOS
##
default HAVE_HARD_RESET=1

default HARD_RESET_BUS=1
default HARD_RESET_DEVICE=4
default HARD_RESET_FUNCTION=0

##
## Build code to export a programmable irq routing table
##
default HAVE_PIRQ_TABLE=1
default IRQ_SLOT_COUNT=12

##
## Build code to export an x86 MP table
## Useful for specifying IRQ routing values
##
default HAVE_MP_TABLE=1

##
## Build code to export a CMOS option table
##
default HAVE_OPTION_TABLE=1

##
## Move the default LinuxBIOS cmos range off of AMD RTC registers
##
default LB_CKS_RANGE_START=49
default LB_CKS_RANGE_END=122
default LB_CKS_LOC=123

##
## Build code for SMP support
## Only worry about 2 micro processors
##
default CONFIG_SMP=1
default CONFIG_MAX_CPUS=2

##
## Build code to setup a generic IOAPIC
##
default CONFIG_IOAPIC=1

##
## Clean up the motherboard id strings
##
default MAINBOARD_PART_NUMBER="HDAMA"
default MAINBOARD_VENDOR="ARIMA"

###
### LinuxBIOS layout values
###

## ROM_IMAGE_SIZE is the amount of space to allow linuxBIOS to occupy.
default ROM_IMAGE_SIZE = 65536

##
## Use a small 8K stack
##
default STACK_SIZE=0x2000

##
## Use a small 16K heap
##
default HEAP_SIZE=0x8000

##
## Only use the option table in a normal image
##
default USE_OPTION_TABLE = !USE_FALLBACK_IMAGE

##
## Compute the location and size of where this firmware image
## (linuxBIOS plus bootloader) will live in the boot rom chip.
##
if USE_FALLBACK_IMAGE
	default ROM_SECTION_SIZE   = FALLBACK_SIZE
	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
else
	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
	default ROM_SECTION_OFFSET = 0
end

##
## Compute the start location and size size of
## The linuxBIOS bootloader.
##
default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
default CONFIG_ROM_STREAM_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
default CONFIG_ROM_STREAM     = 1

##
## Compute where this copy of linuxBIOS will start in the boot rom
##
default _ROMBASE      = ( CONFIG_ROM_STREAM_START + PAYLOAD_SIZE )

##
## Compute a range of ROM that can cached to speed up linuxBIOS,
## execution speed.
##
## XIP_ROM_SIZE must be a power of 2.
## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
##
default XIP_ROM_SIZE=65536
default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )

##
## Set all of the defaults for an x86 architecture
##

arch i386 end
#cpu k8 end

##
## Build the objects we have code for in this directory.
##

driver mainboard.o
if HAVE_MP_TABLE object mptable.o end
if HAVE_PIRQ_TABLE object irq_tables.o end

##
## Romcc output
##
makerule ./failover.E
	depends "$(MAINBOARD)/failover.c" 
	action "$(CPP) -I$(TOP)/src $(ROMCCPPFLAGS) $(CPPFLAGS) $(MAINBOARD)/failover.c > ./failover.E"
end

makerule ./failover.inc
	depends "./failover.E ./romcc"
	action "./romcc -O -o failover.inc --label-prefix=failover ./failover.E"
end

makerule ./auto.E 
	depends	"$(MAINBOARD)/auto.c option_table.h " 
	action	"$(CPP) -I$(TOP)/src -I. $(ROMCCPPFLAGS) $(CPPFLAGS) $(MAINBOARD)/auto.c > ./auto.E"
end
makerule ./auto.inc 
	depends "./auto.E ./romcc"
	action	"./romcc -mcpu=k8 -O2 ./auto.E > auto.inc"
end

##
## Build our 16 bit and 32 bit linuxBIOS entry code
##
mainboardinit cpu/i386/entry16.inc
mainboardinit cpu/i386/entry32.inc
mainboardinit cpu/i386/bist32.inc
ldscript /cpu/i386/entry16.lds
ldscript /cpu/i386/entry32.lds

##
## Build our reset vector (This is where linuxBIOS is entered)
##
if USE_FALLBACK_IMAGE 
	mainboardinit cpu/i386/reset16.inc 
	ldscript /cpu/i386/reset16.lds 
else
	mainboardinit cpu/i386/reset32.inc 
	ldscript /cpu/i386/reset32.lds 
end

### Should this be in the northbridge code?
mainboardinit arch/i386/lib/cpu_reset.inc

##
## Include an id string (For safe flashing)
##
mainboardinit arch/i386/lib/id.inc
ldscript /arch/i386/lib/id.lds

##
## Setup our mtrrs
##
mainboardinit cpu/k8/earlymtrr.inc

###
### This is the early phase of linuxBIOS startup 
### Things are delicate and we test to see if we should
### failover to another image.
###
if USE_FALLBACK_IMAGE
	ldscript /arch/i386/lib/failover.lds 
	mainboardinit ./failover.inc
end

###
### O.k. We aren't just an intermediary anymore!
###

##
## Setup RAM
##
mainboardinit cpu/k8/enable_mmx_sse.inc
mainboardinit ./auto.inc
mainboardinit cpu/k8/disable_mmx_sse.inc

##
## Include the secondary Configuration files 
##
dir /pc80
config chip.h

chip northbridage/amd/amdk8 # mc0
	device pci_domain 0 on
		device pci 18.0 on end # LDT 0 
		device pci 18.0 on end # LDT1
		device pci 18.0 on     # LDT2
			chip southbridge/amd/amd8131
				# the on/off keyword is mandatory
				device pci 0.0 on end
				device pci 0.1 on end
				device pci 1.0 on end
				device pci 1.1 on end
			end
			chip southbridge/amd/amd8111
				# this "device pci 0.0" is the parent the next one
				# PCI bridge
				device pci 0.0 on
					device pci 0.0 on end
					device pci 0.1 on end
					device pci 0.2 on end
					device pci 1.0 off end
				end
				device pci 1.0 on
					chip superio/windond/w83627hf
						device	pnp 2e.0 on  # Floppy 
							 io 0x60 = 0x3f0
							irq 0x70 = 6
							drq 0x74 = 2
						end
						device pnp 2e.1 off  # Parallel Port
							 io 0x60 = 0x378
							irq 0x70 = 7
						end
						device pnp 2e.2 on # Com 1
							 io 0x60 = 0x3f8
							irq 0x70 = 4
						end
						device pnp 2e.3 off # Com 2
							 io 0x60 = 0x2f8
							irq 0x70 = 3
						end
						device pnp 2e.5 on  # Keyboard
							 io 0x60 = 0x60
							 io 0x62 = 0x64
							irq 0x70 = 1
							irq 0x72 = 12
						end
						device pnp 2e.6 off end # CIR
						device pnp 2e.7 off end # GAM_MIDI_GIPO1
						device pnp 2e.8 off end # GPIO2
						device pnp 2e.9 off end # GPIO3
						device pnp 2e.a off end # ACPI
						device pnp 2e.b on      # HW Monitor
							 io 0x60 = 0x290
						end 
					end
				end
				device pci 1.1 on end
				device pci 1.2 on end
				device pci 1.3 on end
				device pci 1.5 off end
				device pci 1.6 off end
			end
		end #  device pci 18.0 
		
		device pci 18.1 on end
		device pci 18.2 on end
		device pci 18.3 on end

		chip northbridge/amd/amdk8
			device pci 19.0 on end
			device pci 19.0 on end
			device pci 19.0 on end
			device pci 19.1 on end
			device pci 19.2 on end
			device pci 19.3 on end
		end
	end
	device apci_cluster 0 on
		chip cpu/amd/socket_940
			device apic 0 on end
		end
		chip cpu/amd/socket_940
			device apic 1 on end
		end
	end
end

##
## Include the old serial code for those few places that still need it.
##
mainboardinit pc80/serial.inc
mainboardinit arch/i386/lib/console.inc
mainboardinit cpu/i386/bist32_fail.inc

