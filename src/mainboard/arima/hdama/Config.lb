##
## Compute the location and size of where this firmware image
## (coreboot plus bootloader) will live in the boot rom chip.
##
if USE_FALLBACK_IMAGE
	default ROM_SECTION_SIZE   = FALLBACK_SIZE
	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
else
	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
	default ROM_SECTION_OFFSET = 0
end

##
## Compute the start location and size size of
## The coreboot bootloader.
##
default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)

##
## Compute where this copy of coreboot will start in the boot rom
##
default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )

##
## Compute a range of ROM that can cached to speed up coreboot,
## execution speed.
##
## XIP_ROM_SIZE must be a power of 2.
## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
##
default XIP_ROM_SIZE=131072
default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )

##
## Set all of the defaults for an x86 architecture
##

arch i386 end

##
## Build the objects we have code for in this directory.
##

driver mainboard.o
if HAVE_MP_TABLE object mptable.o end
if HAVE_PIRQ_TABLE object irq_tables.o end

if CONFIG_USE_INIT

makerule ./auto.o
        depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
        action "$(CC) $(DISTRO_CFLAGS) $(CFLAGS) $(CPPFLAGS) -I$(TOP)/src -I. -c $(MAINBOARD)/cache_as_ram_auto.c -o $@"
end

else    
                
makerule ./auto.inc
        depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
        action "$(CC) $(DISTRO_CFLAGS) $(CFLAGS) $(CPPFLAGS) $(DEBUG_CFLAGS) -I$(TOP)/src -I. -c -S $(MAINBOARD)/cache_as_ram_auto.c -o $@"
        action "perl -e 's/\.rodata/.rom.data/g' -pi $@"
        action "perl -e 's/\.text/.section .rom.text/g' -pi $@"
end

end

##
## Build our 16 bit and 32 bit coreboot entry code
##
if USE_FALLBACK_IMAGE
        mainboardinit cpu/x86/16bit/entry16.inc
        ldscript /cpu/x86/16bit/entry16.lds
end

mainboardinit cpu/x86/32bit/entry32.inc

        if CONFIG_USE_INIT
                ldscript /cpu/x86/32bit/entry32.lds
        end

        if CONFIG_USE_INIT
                ldscript      /cpu/amd/car/cache_as_ram.lds
        end

##
## Build our reset vector (This is where coreboot is entered)
##
if USE_FALLBACK_IMAGE 
	mainboardinit cpu/x86/16bit/reset16.inc
	ldscript /cpu/x86/16bit/reset16.lds
else
	mainboardinit cpu/x86/32bit/reset32.inc
	ldscript /cpu/x86/32bit/reset32.lds
end

##
## Include an id string (For safe flashing)
##
mainboardinit arch/i386/lib/id.inc
ldscript /arch/i386/lib/id.lds

##
## Setup Cache-As-Ram
##
mainboardinit cpu/amd/car/cache_as_ram.inc

###
### This is the early phase of coreboot startup 
### Things are delicate and we test to see if we should
### failover to another image.
###
if USE_FALLBACK_IMAGE
       ldscript /arch/i386/lib/failover.lds
end

###
### O.k. We aren't just an intermediary anymore!
###

##
## Setup RAM
##
if CONFIG_USE_INIT
initobject auto.o
else
mainboardinit ./auto.inc
end

##
## Include the secondary Configuration files 
##
config chip.h

# config for arima/hdama
chip northbridge/amd/amdk8/root_complex
	device apic_cluster 0 on
		chip cpu/amd/socket_940
			device apic 0 on end
		end
	end
	device pci_domain 0 on
		chip northbridge/amd/amdk8
			device pci 18.0 on #  northbridge 
				#  devices on link 0, link 0 == LDT 0 
				chip southbridge/amd/amd8131
					# the on/off keyword is mandatory
					device pci 0.0 on	# PCIX bridge
						## On board NIC A
						#chip drivers/generic/generic
						#	device pci 3.0 on	
						#		irq 0 = 0x13
						#	end
						#end
						## On board NIC B
						#chip drivers/generic/generic
						#	device pci 4.0 on
						#		irq 0 = 0x13
						#	end
						#end
						## PCI Slot 3
						#chip drivers/generic/generic
						#	device pci 1.0 on
						#		irq 0 = 0x11
						#		irq 1 = 0x12
						#		irq 2 = 0x13
						#		irq 3 = 0x10
						#	end
						#end 
						## PCI Slot 4
						#chip drivers/generic/generic
						#	device pci 2.0 on
						#		irq 0 = 0x12
						#		irq 1 = 0x13
						#		irq 2 = 0x10
						#		irq 3 = 0x11
						#	end
						#end 
					end
					device pci 0.1 on end	# IOAPIC
					device pci 1.0 on 	# PCIX bridge
						## PCI Slot 1
						#chip drivers/generic/generic
						#	device pci 1.0 on
						#		irq 0 = 0x11
						#		irq 1 = 0x12
						#		irq 2 = 0x13
						#		irq 3 = 0x10
						#	end
						#end
						## PCI Slot 2
						#chip drivers/generic/generic
						#	device pci 2.0 on
						#		irq 0 = 0x12
						#		irq 1 = 0x13
						#		irq 2 = 0x10
						#		irq 3 = 0x11
						#	end
						#end 
					end
					device pci 1.1 on end	# IOAPIC
				end
				chip southbridge/amd/amd8111
					# this "device pci 0.0" is the parent of the next one
					# PCI bridge
					device pci 0.0 on
						device pci 0.0 on  end	# USB0
						device pci 0.1 on  end	# USB1
						device pci 0.2 off end	# USB 2.0
						device pci 1.0 off end	# LAN
						chip drivers/pci/onboard
							device pci 6.0 on end # ATI Rage XL
							register "rom_address" = "0xfff80000"
						end
						## PCI Slot 5 (correct?)
						#chip drivers/generic/generic
						#	device pci 5.0 on
						#		irq 0 = 0x11
						#		irq 1 = 0x12
						#		irq 2 = 0x13
						#		irq 3 = 0x10
						#	end
						#end 
						## PCI Slot 6 (correct?)
						#chip drivers/generic/generic
						#	device pci 4.0 on
						#		irq 0 = 0x10
						#		irq 1 = 0x11
						#		irq 2 = 0x12
						#		irq 3 = 0x13
						#	end
						#end 

					end
					# LPC bridge
					device pci 1.0 on
						chip superio/nsc/pc87360
							device	pnp 2e.0 off  # Floppy 
								 io 0x60 = 0x3f0
								irq 0x70 = 6
								drq 0x74 = 2
							end
							device pnp 2e.1 off  # Parallel Port
								 io 0x60 = 0x378
								irq 0x70 = 7
							end
							device pnp 2e.2 off # Com 2
								 io 0x60 = 0x2f8
								irq 0x70 = 3
							end
							device pnp 2e.3 on  # Com 1
								 io 0x60 = 0x3f8
								irq 0x70 = 4
							end
							device pnp 2e.4 off end # SWC
							device pnp 2e.5 off end # Mouse
							device pnp 2e.6 on  # Keyboard
								 io 0x60 = 0x60
								 io 0x62 = 0x64
								irq 0x70 = 1
							end
							device pnp 2e.7 off end # GPIO
							device pnp 2e.8 off end # ACB
							device pnp 2e.9 off end # FSCM
							device pnp 2e.a off end # WDT  
						end
					end
					device pci 1.1 on end	# IDE
					device pci 1.2 on end	# SMBus 2.0
					device pci 1.3 on 	# System Management
						chip drivers/generic/generic
							#phillips pca9545 smbus mux
							device i2c 70 on 
								# analog_devices adm1026	
								chip drivers/generic/generic
									device i2c 2c on end
								end
							end
							device i2c 70 on end
							device i2c 70 on end
							device i2c 70 on end
						end
						chip drivers/generic/generic #dimm 0-0-0
							device i2c 50 on end
						end
						chip drivers/generic/generic #dimm 0-0-1
							device i2c 51 on end
						end 
						chip drivers/generic/generic #dimm 0-1-0
							device i2c 52 on end
						end 
						chip drivers/generic/generic #dimm 0-1-1
							device i2c 53 on end
						end 
						chip drivers/generic/generic #dimm 1-0-0
							device i2c 54 on end 
						end
						chip drivers/generic/generic #dimm 1-0-1
							device i2c 55 on end
						end 
						chip drivers/generic/generic #dimm 1-1-0
							device i2c 56 on end
						end 
						chip drivers/generic/generic #dimm 1-1-1
							device i2c 57 on end
						end 
					end
					device pci 1.5 off end	# AC97 Audio
					device pci 1.6 on  end	# AC97 Modem
					register "ide0_enable" = "1"
					register "ide1_enable" = "1"
				end
			end #  device pci 18.0 
			
			device pci 18.0 on end # LDT1
			device pci 18.0 on end # LDT2
			device pci 18.1 on end
			device pci 18.2 on end
			device pci 18.3 on end
		end  # chip northbridge/amd/amdk8
		chip northbridge/amd/amdk8
			device pci 19.0 on end
			device pci 19.0 on end
			device pci 19.0 on end
			device pci 19.1 on end
			device pci 19.2 on end
			device pci 19.3 on end
		end
	end 
end

