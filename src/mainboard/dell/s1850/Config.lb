##
## Only use the option table in a normal image
##
default USE_OPTION_TABLE = !USE_FALLBACK_IMAGE

##
## Compute the location and size of where this firmware image
## (coreboot plus bootloader) will live in the boot rom chip.
##
if USE_FALLBACK_IMAGE
	default ROM_SECTION_SIZE   = FALLBACK_SIZE
	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
else
	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
	default ROM_SECTION_OFFSET = 0
end

##
## Compute the start location and size size of
## The coreboot bootloader.
##
default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)

##
## Compute where this copy of coreboot will start in the boot rom
##
default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )

##
## Compute a range of ROM that can cached to speed up coreboot,
## execution speed.
##
## XIP_ROM_SIZE must be a power of 2.
## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
##
default XIP_ROM_SIZE=131072
default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )

##
## Set all of the defaults for an x86 architecture
##

arch i386 end

##
## Build the objects we have code for in this directory.
##

driver mainboard.o
if HAVE_MP_TABLE object mptable.o end
if HAVE_PIRQ_TABLE object irq_tables.o end
object reset.o

##
## Romcc output
##
makerule ./failover.E
	depends "$(MAINBOARD)/failover.c ./romcc" 
	action "./romcc -fno-simplify-phi -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
end

makerule ./failover.inc
	depends "$(MAINBOARD)/failover.c ./romcc"
	action "./romcc -fno-simplify-phi -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
end

makerule ./auto.E 
	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
	action	"./romcc -fno-simplify-phi -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
end
makerule ./auto.inc 
	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
	action	"./romcc -fno-simplify-phi -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
end

##
## Build our 16 bit and 32 bit coreboot entry code
##
mainboardinit cpu/x86/16bit/entry16.inc
mainboardinit cpu/x86/32bit/entry32.inc
ldscript /cpu/x86/16bit/entry16.lds
ldscript /cpu/x86/32bit/entry32.lds

##
## Build our reset vector (This is where coreboot is entered)
##
if USE_FALLBACK_IMAGE 
	mainboardinit cpu/x86/16bit/reset16.inc
	ldscript /cpu/x86/16bit/reset16.lds
else
	mainboardinit cpu/x86/32bit/reset32.inc
	ldscript /cpu/x86/32bit/reset32.lds
end

### Should this be in the northbridge code?
mainboardinit arch/i386/lib/cpu_reset.inc

##
## Include an id string (For safe flashing)
##
mainboardinit arch/i386/lib/id.inc
ldscript /arch/i386/lib/id.lds

###
### This is the early phase of coreboot startup 
### Things are delicate and we test to see if we should
### failover to another image.
###
if USE_FALLBACK_IMAGE
	ldscript /arch/i386/lib/failover.lds 
	mainboardinit ./failover.inc
end

###
### O.k. We aren't just an intermediary anymore!
###

##
## Setup RAM
##
mainboardinit cpu/x86/fpu/enable_fpu.inc
mainboardinit cpu/x86/mmx/enable_mmx.inc
mainboardinit cpu/x86/sse/enable_sse.inc
mainboardinit ./auto.inc
mainboardinit cpu/x86/sse/disable_sse.inc
mainboardinit cpu/x86/mmx/disable_mmx.inc

##
## Include the secondary Configuration files 
##
dir /pc80
config chip.h

chip northbridge/intel/e7520 # mch
	device pci_domain 0 on 
		chip southbridge/intel/i82801er # i82801er
			# USB ports
			device pci 1d.0 on end
			device pci 1d.1 on end
			device pci 1d.2 on end 
			device pci 1d.3 on end
			device pci 1d.7 on end
		
			# -> Bridge
			device pci 1e.0 on end
		
			# -> ISA
			device pci 1f.0 on 
				chip superio/nsc/pc8374
					device pnp 2e.0 off end
					device pnp 2e.1 off end
					device pnp 2e.2 off end
					device pnp 2e.3 on 
						 io 0x60 = 0x3f8
						irq 0x70 = 4
					end
					device pnp 2e.4 off end
					device pnp 2e.5 off end
					device pnp 2e.6 off end
					device pnp 2e.7 off end
					device pnp 2e.8 off end
				end
			end
			# -> IDE
			device pci 1f.1 on end
			# -> SATA 
			device pci 1f.2 on end
			device pci 1f.3 on end

			register "pirq_a_d" = "0x8a07030b"
			register "pirq_e_h" = "0x85808080"
		end
		device pci 00.0 on end 
		device pci 00.1 on end
		device pci 01.0 on end 
		device pci 02.0 on 
			chip southbridge/intel/pxhd # pxhd1
				# Bus bridges and ioapics usually bus 1
				device pci 0.0 on 
				# On board gig e1000
					chip drivers/generic/generic 
        		        	        device pci 03.0 on end
        		        	        device pci 03.1 on end
        		        	end
				end
				device pci 0.1 on end
				device pci 0.2 on end
				device pci 0.3 on end
			end
		end
		device pci 04.0 on end
		device pci 06.0 on end
	end
	device apic_cluster 0 on
		chip cpu/intel/socket_mPGA604_800Mhz # cpu 0
			device apic 0 on end
		end
		chip cpu/intel/socket_mPGA604_800Mhz # cpu 1
			device apic 6 on end
		end
	end
	register "intrline" = "0x00070100"
end

