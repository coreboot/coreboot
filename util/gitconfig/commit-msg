#!/bin/sh
#
# Part of Gerrit Code Review (http://code.google.com/p/gerrit/)
#
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

CHANGE_ID_AFTER="Bug|Issue"
MSG="$1"

# Check for, and add if missing, a unique Change-Id
#
add_ChangeId() {
	clean_message=`sed -e '
		/^diff --git a\/.*/{
			s///
			q
		}
		/^Signed-off-by:/d
		/^#/d
	' "$MSG" | git stripspace`
	if test -z "$clean_message"
	then
		return
	fi

	# Does Change-Id: already exist? if so, exit (no change).
	if grep -i '^Change-Id:' "$MSG" >/dev/null
	then
		return
	fi

	id=`_gen_ChangeId`
	T="$MSG.tmp.$$"
	AWK=awk
	if [ -x /usr/xpg4/bin/awk ]; then
		# Solaris AWK is just too broken
		AWK=/usr/xpg4/bin/awk
	fi
	$AWK '
	# Skip lines starting with "#" without any spaces before it.
	/^#/ { next }

	# Skip the line starting with the diff command and everything after it,
	# up to the end of the file, assuming it is only patch data.
	# If more than one line before the diff was empty, strip all but one.
	/^diff --git a/ {
		if (blankLines > 1) {
			blankLines = 1
		}
		while (getline) { }
		next
	}

	# Handle comments and continuations in tags ([foo: bar] etc)
	(caught == 1) && /^[ []/ {
		if (lines != "") {
			lines = lines "\n"
		}
		lines = lines $0
		next
	}

	# Handle normal lines (ie. not starting with some tag like "Signed-off-by:").
	# If normal text appears after tags were "caught", handle them as normal text, too.
	# Also count blank lines in blankLines.
	!/^[a-zA-Z0-9-]+:/ || /^[a-zA-Z0-9-]+:\/\// {
		if ($0 == "") {
			blankLines++
			next
		} else {
			for (i = 0; i < blankLines; i++) {
				print ""
			}
			blankLines = 0
		}
		if (caught == 1) {
			caught = 0
			print lines
			lines = ""
		}
		print $0
		next
	}

	# Handle tags.  They are "caught" and collected in the "lines" variable
	{
		caught = 1
		if (lines != "") {
			lines = lines "\n";
		}
		lines = lines $0
	}

	# Tag handling:
	# If last line before tags was not blank, there were no tags.
	# In that case, print everything, plus a blank line, followed by Change-Id.
	# Otherwise there were tags. Look for the right place to inject Change-Id,
	# by considering CHANGE_ID_AFTER. Tags listed in it (case insensitive) come first,
	# then Change-Id, then everything else (eg. Signed-off-by:).
	END {
		unprinted = 1
		if (blankLines == 0) {
			if (lines == "") {
				 print ""
			} else {
				print lines "\n"
			}
		} else {
			for (i = 0; i < blankLines; i++) {
				print ""
			}
			changeIdAfter = "^(" tolower("'"$CHANGE_ID_AFTER"'") "):"
			numlines = split(lines, footer, "\n")
			for (line = 1; line <= numlines; line++) {
				if (unprinted && match(tolower(footer[line]), changeIdAfter) != 1) {
					unprinted = 0
					print "Change-Id: I'"$id"'"
				}
				print footer[line]
			}
		}
		if (unprinted) {
			print "Change-Id: I'"$id"'"
		}
	}' "$MSG" > $T && mv $T "$MSG" || rm -f $T
}
_gen_ChangeIdInput() {
	echo "tree `git write-tree`"
	if parent=`git rev-parse "HEAD^0" 2>/dev/null`
	then
		echo "parent $parent"
	fi
	echo "author `git var GIT_AUTHOR_IDENT`"
	echo "committer `git var GIT_COMMITTER_IDENT`"
	echo
	printf '%s' "$clean_message"
}
_gen_ChangeId() {
	_gen_ChangeIdInput |
	git hash-object -t commit --stdin
}


add_ChangeId
